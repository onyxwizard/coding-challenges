# ğŸ“˜ **121. Best Time to Buy and Sell Stock â€“ Comprehensive Solution**

## ğŸ“‹ **Problem Statement**

Given an array `prices` where `prices[i]` is the stock price on day `i`, find the **maximum profit** achievable by buying on one day and selling on a **later day**.

### ğŸ¯ **Key Requirements**:
- **Buy before sell**: cannot sell before buying
- **Single transaction**: only one buy and one sell
- **Non-negative profit**: return 0 if no profit possible
- Handle large arrays efficiently (up to 10âµ elements)

## ğŸ§  **Core Insight: Transform to Maximum Subarray Problem**

### ğŸ”‘ **The Fundamental Transformation**:

This problem can be transformed into a **maximum subarray problem** by considering **price differences**:

1. **Calculate differences**: `diff[i] = prices[i] - prices[i-1]` for `i = 1 to n-1`
2. **Maximum profit** = **maximum subarray sum** of the difference array

### ğŸ’¡ **Why This Works**:
- Buying on day `i` and selling on day `j` gives profit = `prices[j] - prices[i]`
- This equals the sum of differences: `(prices[i+1]-prices[i]) + ... + (prices[j]-prices[j-1])`
- So maximum profit = maximum sum of contiguous differences

### ğŸ“Š **Example Transformation**:
```
prices = [7, 1, 5, 3, 6, 4]
diff =    [-6, 4, -2, 3, -2]
max subarray sum = 4 + (-2) + 3 = 5
```

---

## âœ… **Multiple Solution Approaches**

### ğŸ”¹ **Approach 1: Kadane's Algorithm on Differences (O(n) time, O(1) space)**

#### **Logic**:
- Transform to difference array
- Apply Kadane's algorithm for maximum subarray sum

#### **Code**:
```java
public static int maxProfitKadane(int[] prices) {
    if (prices == null || prices.length <= 1) {
        return 0;
    }
    
    int maxProfit = 0;
    int currentProfit = 0;
    
    for (int i = 1; i < prices.length; i++) {
        int diff = prices[i] - prices[i - 1];
        currentProfit = Math.max(diff, currentProfit + diff);
        maxProfit = Math.max(maxProfit, currentProfit);
    }
    
    return maxProfit;
}
```

---

### ğŸ”¹ **Approach 2: Single Pass with Minimum Price (Most Intuitive, O(n) time, O(1) space)**

#### **Logic**:
- Track minimum price seen so far
- For each day, calculate profit if sold today
- Update maximum profit

#### **Code**:
```java
public static int maxProfitSinglePass(int[] prices) {
    if (prices == null || prices.length <= 1) {
        return 0;
    }
    
    int minPrice = prices[0];
    int maxProfit = 0;
    
    for (int i = 1; i < prices.length; i++) {
        // Update minimum price seen so far
        minPrice = Math.min(minPrice, prices[i]);
        // Calculate profit if sold today
        int profit = prices[i] - minPrice;
        // Update maximum profit
        maxProfit = Math.max(maxProfit, profit);
    }
    
    return maxProfit;
}
```

---

### ğŸ”¹ **Approach 3: Brute Force (O(nÂ²) time, O(1) space) - For Comparison**

#### **Logic**:
- Check all possible buy-sell pairs
- Return maximum profit

#### **Code**:
```java
public static int maxProfitBruteForce(int[] prices) {
    if (prices == null || prices.length <= 1) {
        return 0;
    }
    
    int maxProfit = 0;
    
    for (int i = 0; i < prices.length - 1; i++) {
        for (int j = i + 1; j < prices.length; j++) {
            int profit = prices[j] - prices[i];
            maxProfit = Math.max(maxProfit, profit);
        }
    }
    
    return maxProfit;
}
```

---

## ğŸš€ **Complete Implementation with Test Cases**

```java
public class BestTimeToBuyAndSellStock {

    /**
     * Finds maximum profit from single stock transaction using Kadane's algorithm.
     * 
     * Approach: Transform to maximum subarray problem on price differences
     * 
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * 
     * @param prices stock prices array
     * @return maximum profit achievable
     */
    public static int maxProfitKadane(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        
        int maxProfit = 0;
        int currentProfit = 0;
        
        for (int i = 1; i < prices.length; i++) {
            int diff = prices[i] - prices[i - 1];
            currentProfit = Math.max(diff, currentProfit + diff);
            maxProfit = Math.max(maxProfit, currentProfit);
        }
        
        return maxProfit;
    }

    /**
     * Finds maximum profit using single pass with minimum price tracking.
     * 
     * Approach: Track minimum price and calculate max profit on each day
     * 
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * 
     * @param prices stock prices array
     * @return maximum profit achievable
     */
    public static int maxProfitSinglePass(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        
        int minPrice = prices[0];
        int maxProfit = 0;
        
        for (int i = 1; i < prices.length; i++) {
            minPrice = Math.min(minPrice, prices[i]);
            int profit = prices[i] - minPrice;
            maxProfit = Math.max(maxProfit, profit);
        }
        
        return maxProfit;
    }

    /**
     * Finds maximum profit using brute force approach.
     * 
     * Approach: Check all possible buy-sell pairs
     * 
     * Time Complexity: O(nÂ²)
     * Space Complexity: O(1)
     * 
     * @param prices stock prices array
     * @return maximum profit achievable
     */
    public static int maxProfitBruteForce(int[] prices) {
        if (prices == null || prices.length <= 1) {
            return 0;
        }
        
        int maxProfit = 0;
        
        for (int i = 0; i < prices.length - 1; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                int profit = prices[j] - prices[i];
                maxProfit = Math.max(maxProfit, profit);
            }
        }
        
        return maxProfit;
    }

    // ==================== Comprehensive Test Cases ====================
    public static void main(String[] args) {
        System.out.println("=== Best Time to Buy and Sell Stock ===\n");

        // Example 1: Standard case with profit
        int[] test1 = {7, 1, 5, 3, 6, 4};
        System.out.println("Test 1: prices = " + java.util.Arrays.toString(test1));
        System.out.println("Kadane's: " + maxProfitKadane(test1)); // Expected: 5
        System.out.println("Single Pass: " + maxProfitSinglePass(test1)); // Expected: 5
        System.out.println("Brute Force: " + maxProfitBruteForce(test1)); // Expected: 5

        // Example 2: Decreasing prices (no profit)
        int[] test2 = {7, 6, 4, 3, 1};
        System.out.println("\nTest 2: prices = " + java.util.Arrays.toString(test2) + " (decreasing)");
        System.out.println("Kadane's: " + maxProfitKadane(test2)); // Expected: 0
        System.out.println("Single Pass: " + maxProfitSinglePass(test2)); // Expected: 0

        // Edge Case 1: Single day
        int[] test3 = {5};
        System.out.println("\nTest 3: prices = " + java.util.Arrays.toString(test3) + " (single day)");
        System.out.println("Kadane's: " + maxProfitKadane(test3)); // Expected: 0

        // Edge Case 2: Two days, profit possible
        int[] test4 = {1, 5};
        System.out.println("\nTest 4: prices = " + java.util.Arrays.toString(test4) + " (two days)");
        System.out.println("Kadane's: " + maxProfitKadane(test4)); // Expected: 4

        // Edge Case 3: Two days, no profit
        int[] test5 = {5, 1};
        System.out.println("\nTest 5: prices = " + java.util.Arrays.toString(test5) + " (two days, no profit)");
        System.out.println("Kadane's: " + maxProfitKadane(test5)); // Expected: 0

        // Edge Case 4: All same prices
        int[] test6 = {3, 3, 3, 3};
        System.out.println("\nTest 6: prices = " + java.util.Arrays.toString(test6) + " (all same)");
        System.out.println("Kadane's: " + maxProfitKadane(test6)); // Expected: 0

        // Edge Case 5: Increasing prices
        int[] test7 = {1, 2, 3, 4, 5};
        System.out.println("\nTest 7: prices = " + java.util.Arrays.toString(test7) + " (increasing)");
        System.out.println("Kadane's: " + maxProfitKadane(test7)); // Expected: 4

        // Edge Case 6: Maximum constraint values
        int[] test8 = {10000, 0, 10000};
        System.out.println("\nTest 8: prices = " + java.util.Arrays.toString(test8) + " (max values)");
        System.out.println("Kadane's: " + maxProfitKadane(test8)); // Expected: 10000

        // Edge Case 7: Large array performance test
        System.out.println("\n=== Performance Comparison ===");
        
        // Generate large test case
        int[] largePrices = new int[100000];
        for (int i = 0; i < 100000; i++) {
            largePrices[i] = (int) (Math.random() * 10001);
        }
        
        // Kadane's Algorithm
        long start1 = System.currentTimeMillis();
        int result1 = maxProfitKadane(largePrices);
        long end1 = System.currentTimeMillis();
        
        // Single Pass
        long start2 = System.currentTimeMillis();
        int result2 = maxProfitSinglePass(largePrices);
        long end2 = System.currentTimeMillis();
        
        // Brute Force (only for small n)
        int[] smallPrices = java.util.Arrays.copyOf(largePrices, 1000);
        long start3 = System.currentTimeMillis();
        int result3 = maxProfitBruteForce(smallPrices);
        long end3 = System.currentTimeMillis();
        
        System.out.println("Kadane's (n=100000): " + (end1 - start1) + " ms, Result: " + result1);
        System.out.println("Single Pass (n=100000): " + (end2 - start2) + " ms, Result: " + result2);
        System.out.println("Brute Force (n=1000): " + (end3 - start3) + " ms, Result: " + result3);
        
        // Step-by-step visualization for test1
        System.out.println("\n=== Step-by-Step for Test 1: [7,1,5,3,6,4] ===");
        System.out.println("Differences: [-6, 4, -2, 3, -2]");
        System.out.println("Kadane's progression:");
        int[] diffs = {-6, 4, -2, 3, -2};
        int curr = 0, max = 0;
        for (int i = 0; i < diffs.length; i++) {
            curr = Math.max(diffs[i], curr + diffs[i]);
            max = Math.max(max, curr);
            System.out.println("Day " + (i+2) + " (diff=" + diffs[i] + "): current=" + curr + ", max=" + max);
        }
        
        System.out.println("\nSingle Pass progression:");
        int min = 7, profit = 0;
        for (int i = 1; i < test1.length; i++) {
            min = Math.min(min, test1[i]);
            profit = Math.max(profit, test1[i] - min);
            System.out.println("Day " + (i+1) + " (price=" + test1[i] + "): min=" + min + ", profit=" + profit);
        }
    }
}
```

---

## ğŸ” **Approach Comparison and Analysis**

### ğŸ“Š **Time and Space Complexity**

| Approach | Time Complexity | Space Complexity | Intuition Level | Best Use Case |
|----------|----------------|------------------|-----------------|---------------|
| **Kadane's on Differences** | O(n) | O(1) | Medium | When you want to reuse maximum subarray knowledge |
| **Single Pass with Min** | O(n) | O(1) | **High** | **Production code** - most intuitive |
| **Brute Force** | O(nÂ²) | O(1) | High | Educational purposes only |

### ğŸ¯ **Why Single Pass is Preferred**

1. **Most intuitive**: Directly models the business logic
   - "What's the cheapest I've seen so far?"
   - "What profit would I make if I sold today?"
2. **No transformation needed**: Works directly on prices array
3. **Clear business interpretation**: Each step has real-world meaning
4. **Slightly more efficient**: No subtraction operations needed

### ğŸ§  **Why Kadane's Works**

The transformation to differences is mathematically elegant:
- `prices[j] - prices[i] = Î£(prices[k] - prices[k-1]) for k=i+1 to j`
- Maximum profit = maximum sum of contiguous differences
- This shows the deep connection between different algorithmic problems

---

## ğŸ” **Step-by-Step Example Walkthrough**

### **Example**: `prices = [7, 1, 5, 3, 6, 4]`

#### **Single Pass Approach**:
| Day | Price | Min Price | Profit Today | Max Profit |
|-----|-------|-----------|--------------|------------|
| 1 | 7 | 7 | - | 0 |
| 2 | 1 | **1** | 0 | 0 |
| 3 | 5 | 1 | **4** | **4** |
| 4 | 3 | 1 | 2 | 4 |
| 5 | 6 | 1 | **5** | **5** |
| 6 | 4 | 1 | 3 | 5 |

âœ… Maximum profit = **5**

#### **Kadane's on Differences**:
| Day | Diff | Current Max | Global Max |
|-----|------|-------------|------------|
| 2 | -6 | -6 | 0 |
| 3 | 4 | **4** | **4** |
| 4 | -2 | 2 | 4 |
| 5 | 3 | **5** | **5** |
| 6 | -2 | 3 | 5 |

âœ… Maximum profit = **5**

---

## âš ï¸ **Common Mistakes to Avoid**

### âŒ **Mistake 1: Not Handling Edge Cases**
```java
// Wrong: assumes array has at least 2 elements
for (int i = 1; i < prices.length; i++) { ... }
// Fails for single-element arrays
```

### âŒ **Mistake 2: Updating Min Price After Calculating Profit**
```java
// Wrong order
int profit = prices[i] - minPrice;
minPrice = Math.min(minPrice, prices[i]);
// Uses old minPrice, but should use minPrice before today's price
```

### âœ… **Correct Order**:
```java
minPrice = Math.min(minPrice, prices[i]); // Update before calculating profit
int profit = prices[i] - minPrice;
```

Actually, for the single pass approach, we should calculate profit with the min price **before** today, so:

```java
// Correct order for single pass
int profit = prices[i] - minPrice;        // Use min from previous days
minPrice = Math.min(minPrice, prices[i]); // Update min for next iteration
```

---

## ğŸ’¡ **Real-World Applications**

- **Algorithmic Trading**: Real-time profit maximization
- **E-commerce**: Dynamic pricing optimization
- **Resource Allocation**: Buy low, sell high strategies
- **Educational**: Classic example of greedy algorithms and dynamic programming

---

## ğŸ¯ **Key Takeaways**

1. **Single pass with minimum tracking** is the most intuitive and efficient solution
2. **Kadane's algorithm connection** shows the unity of algorithmic problems
3. **Always handle edge cases**: empty arrays, single element, decreasing sequences
4. **Business logic mapping**: Each algorithmic step should have a real-world interpretation
5. **Performance matters**: O(n) vs O(nÂ²) makes a huge difference for large datasets

This problem is a perfect example of how **simple business requirements** can lead to **elegant algorithmic solutions**! ğŸš€