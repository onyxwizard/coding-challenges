# ğŸ”¢ **LeetCode 1365. How Many Numbers Are Smaller Than the Current Number**

> Given an array `nums`, for each `nums[i]`, return *how many numbers in the array are smaller than `nums[i]`*.

### âœ… Example
```java
Input: nums = [8, 1, 2, 2, 3]
Output: [4, 0, 1, 1, 3]
// For 8 â†’ 4 smaller (1,2,2,3); for 1 â†’ 0; for 2 â†’ 1 (only 1); etc.
```

### ğŸ¯ Constraints
- `2 â‰¤ nums.length â‰¤ 500`
- `0 â‰¤ nums[i] â‰¤ 100` â† **critical: small value range!**


This problem *looks* simple â€” but the constraint `nums[i] â‰¤ 100` is a **gift**. It invites an elegant **counting sort**â€“based solution that runs in **O(n + k)** time, where `k = 101`.

Letâ€™s explore **four approaches**, from brute force to optimal, with deep analysis.

---

## âœ… Version A: Brute Force (Nested Loops)

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    int n = nums.length;
    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (nums[j] < nums[i]) ans[i]++;
        }
    }
    return ans;
}
```

### ğŸ” Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(nÂ²) â†’ 500Â² = 250,000 ops (acceptable) |
| **Space** | O(1) extra |
| **Readability** | â­â­â­â­â­ |
| **LeetCode Runtime** | âœ… ~1â€“2 ms (beats ~70%) |

âœ… **Pros**:  
- Dead simple â€” zero cognitive load.  
- No extra space.

âŒ **Cons**:  
- Doesnâ€™t scale: `n = 10âµ` â†’ 10Â¹â° ops (impossible).  
- Misses the `nums[i] â‰¤ 100` hint â€” an opportunity.

> ğŸ’¡ Use only for tiny `n` or as a baseline.

---

## âœ… Version B: Sorting + HashMap (Stable, O(n log n))

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    int n = nums.length;
    int[] sorted = nums.clone();
    Arrays.sort(sorted);

    // Map: number â†’ first index it appears at (== count of smaller numbers)
    Map<Integer, Integer> firstIndex = new HashMap<>();
    for (int i = 0; i < n; i++) {
        firstIndex.putIfAbsent(sorted[i], i);
    }

    int[] ans = new int[n];
    for (int i = 0; i < n; i++) {
        ans[i] = firstIndex.get(nums[i]);
    }
    return ans;
}
```

### ğŸ” How it works:
- After sorting `[1,2,2,3,8]`, the *first occurrence* index of `2` is `1` â†’ exactly 1 number (`1`) is smaller.

### ğŸ” Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(n log n) â€” dominated by sort |
| **Space** | O(n) â€” clone + map |
| **Readability** | â­â­â­â­ |
| **LeetCode Runtime** | âœ… ~1 ms |

âœ… **Pros**:  
- Handles **duplicates correctly** (thanks to `putIfAbsent`).  
- Works for *any* integer range (not just â‰¤100).

âŒ **Cons**:  
- Overkill for small `k = 101` â€” `n log n = 500 Ã— 9 â‰ˆ 4500` vs `n + k = 601`.

---

## âœ…âœ…âœ… Version C: Counting Sort (Optimal â€” O(n + k))

Leverage `0 â‰¤ nums[i] â‰¤ 100` â†’ `k = 101` buckets.

### ğŸ” Idea:
1. Count frequency of each value: `count[x] = # of times x appears`.
2. Compute prefix sum: `prefix[x] = # of numbers < x = count[0] + ... + count[xâˆ’1]`.
3. For each `nums[i]`, answer is `prefix[nums[i]]`.

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    // Step 1: count frequencies (0 to 100)
    int[] count = new int[101]; // index = number
    for (int num : nums) {
        count[num]++;
    }

    // Step 2: compute prefix: prefix[i] = count[0] + ... + count[i-1]
    int[] prefix = new int[102]; // prefix[0] = 0, prefix[101] for safety
    for (int i = 1; i <= 101; i++) {
        prefix[i] = prefix[i - 1] + count[i - 1];
    }

    // Step 3: answer[i] = prefix[nums[i]]
    int[] ans = new int[nums.length];
    for (int i = 0; i < nums.length; i++) {
        ans[i] = prefix[nums[i]];
    }
    return ans;
}
```

### ğŸ” Walkthrough (`nums = [8,1,2,2,3]`)
| `count` (index = value) | `[0]=0, [1]=1, [2]=2, [3]=1, [4..7]=0, [8]=1, ...` |
| `prefix` | `prefix[0]=0`, `prefix[1]=0`, `prefix[2]=1`, `prefix[3]=1+2=3`, `prefix[4]=4`, ..., `prefix[8]=4` |
â†’ `ans[0] = prefix[8] = 4`, `ans[1] = prefix[1] = 0`, `ans[2] = prefix[2] = 1`, etc. âœ…

### ğŸ” Analysis
| Metric | Value |
|-------|-------|
| **Time** | âœ… **O(n + 101) = O(n)** â€” optimal |
| **Space** | O(101) = **O(1)** (fixed size) |
| **Readability** | â­â­â­ |
| **LeetCode Runtime** | âœ… **0 ms** (beats 100%) |

âœ… **Pros**:  
- Linear time, constant extra space (101 is fixed!).  
- No sorting, no hashing â€” pure counting.  
- Scales to `n = 10â·` effortlessly.

âŒ **Cons**:  
- Only works because `nums[i] â‰¤ 100` â€” but problem *gives* us this!

> ğŸ’¡ This is the **intended optimal solution** â€” LeetCodeâ€™s constraints are a hint.

---

## âœ… Version D: TreeMap (Over-Engineered â€” For Fun)

```java
public int[] smallerNumbersThanCurrent(int[] nums) {
    TreeMap<Integer, Integer> freq = new TreeMap<>();
    for (int num : nums) freq.merge(num, 1, Integer::sum);

    // Build prefix map
    Map<Integer, Integer> prefix = new HashMap<>();
    int sum = 0;
    for (int key : freq.keySet()) {
        prefix.put(key, sum);
        sum += freq.get(key);
    }

    return Arrays.stream(nums).map(prefix::get).toArray();
}
```

âœ… Works, but:
- O(n log k) time (`k â‰¤ 101` â†’ log 101 â‰ˆ 7, so fine),
- But heavier than counting array.

â¡ï¸ Not recommended â€” shows knowledge of `TreeMap`, but counting array is simpler.

---

## ğŸ“Š Head-to-Head Comparison

| Approach | Time | Space | Scalability | LeetCode Speed | When to Use |
|---------|------|-------|-------------|----------------|-------------|
| **A. Brute Force** | O(nÂ²) | O(1) | âŒ Poor | ~2 ms | Tiny `n`, quick draft |
| **B. Sort + Map** | O(n log n) | O(n) | âœ… Good | ~1 ms | General integers, no range constraint |
| **âœ… C. Counting Sort** | âœ… **O(n)** | âœ… **O(1)** | âœ… Excellent | âœ… **0 ms** | **Best for this problem** â€” use it! |
| **D. TreeMap** | O(n log k) | O(k) | âœ… Good | ~2 ms | Demonstrating ordered maps (interview flair) |

---

## ğŸ§  Why Counting Sort Shines Here

The constraint `0 â‰¤ nums[i] â‰¤ 100` is **not accidental** â€” itâ€™s LeetCodeâ€™s way of guiding you toward counting.

Think of it as:
- **n = 500**: data size  
- **k = 101**: domain size  

When `k â‰ª n log n` (here, `101 â‰ª 500Ã—9 = 4500`), **counting beats sorting**.

This is the same insight behind:
- **Sort Colors** (LeetCode 75) â€” 3 colors â†’ counting sort,
- **Top K Frequent Elements** with bounded values.

## âœ… Final Recommendation

| Context | Best Choice |
|--------|-------------|
| ğŸ“ Learning | **A â†’ C** (show progression) |
| ğŸ’¼ Interview | Start with **A**, then optimize to **C** using the `â‰¤100` hint:  
  *â€œI notice values are bounded â€” we can use counting sort for O(n) time.â€* |
| ğŸ­ Production | **C** â€” fastest, most efficient, no surprises |
| ğŸ† Competitive | **C** â€” 5 lines, 0 ms |


## ğŸ”š Bonus: Edge Cases & Extensions

| Case | Handling |
|------|----------|
| `[0,0,0]` | `count[0]=3`, `prefix[0]=0` â†’ `[0,0,0]` âœ… |
| `[5,5,5,5]` | All get `prefix[5]` = count of `<5` âœ… |
| `n = 500`, all `100` | `prefix[100] = sum(count[0..99])` â†’ correct |

### ğŸ”„ Generalization: *What if `nums[i] â‰¤ 10â¶`?*
- Use **Version B (sort + map)** â€” `O(n log n)` is fine for `n â‰¤ 10âµ`.
- Or try **radix sort** â€” but overkill.
