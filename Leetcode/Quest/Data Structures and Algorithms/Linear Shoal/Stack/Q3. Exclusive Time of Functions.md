# â±ï¸ **LeetCode 636. Exclusive Time of Functions**  
*Compute exclusive execution time for each function in a single-threaded call stack.*

## ğŸ“Œ Problem Summary

Youâ€™re given:
- `n`: number of functions (IDs: `0` to `nâˆ’1`),
- `logs`: list of strings like `"id:start|end:timestamp"`.

### ğŸ§  Key Concepts
- **Single-threaded CPU**: only one function runs at a time.
- **Call stack**: `start` â†’ push, `end` â†’ pop.
- **Timestamp semantics**:
  - `"id:start:t"` â†’ function starts at **beginning** of timestamp `t`.
  - `"id:end:t"` â†’ function ends at **end** of timestamp `t`.
  â†’ So a function running from `start:2` to `end:5` executes for `5 âˆ’ 2 + 1 = 4` units.

### âœ… Example 1  
`n = 2`, `logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]`  
â†’ Output: `[3, 4]`

| Time | Event | Stack | Whoâ€™s running? |
|------|-------|-------|----------------|
| 0 (start) | `0:start` | `[0]` | 0 runs at t=0,1 â†’ 2 units |
| 2 (start) | `1:start` | `[0,1]` | 1 runs at t=2,3,4,5 â†’ 4 units |
| 6 (end)   | `0:end`   | `[]`    | 0 resumes at t=6 â†’ 1 unit |

â†’ 0: `2 + 1 = 3`, 1: `4` â†’ `[3,4]` âœ…


## ğŸ”‘ Core Insight: Stack + Time Accounting

We simulate the call stack and **attribute time to the currently running function**.

But hereâ€™s the subtlety:

> When a new function starts, the **previous top function is preempted** â€” so we must **pause its timer** and start the new one.

Similarly, when a function ends, the **previous function resumes** â€” so we add time to the ending function, then resume the caller.

Weâ€™ll maintain:
- `stack`: function IDs (call stack),
- `prevTime`: last event timestamp,
- `result[i]`: exclusive time for function `i`.

---

## âœ… Approach: Stack Simulation (Optimal â€” O(L))

```java
import java.util.*;

public class Solution {
    public int[] exclusiveTime(int n, List<String> logs) {
        int[] result = new int[n];
        Stack<Integer> stack = new Stack<>();
        int prevTime = 0;

        for (String log : logs) {
            String[] parts = log.split(":");
            int id = Integer.parseInt(parts[0]);
            String type = parts[1];
            int time = Integer.parseInt(parts[2]);

            if (!stack.isEmpty()) {
                int runningId = stack.peek();
                if (type.equals("start")) {
                    // Previous function is preempted at beginning of `time`
                    result[runningId] += time - prevTime;
                    stack.push(id);
                    prevTime = time;
                } else { // "end"
                    // Current function runs until *end* of `time`
                    result[id] += time - prevTime + 1;
                    stack.pop();
                    prevTime = time + 1; // next start happens at beginning of next timestamp
                }
            } else {
                // First start
                stack.push(id);
                prevTime = time;
            }
        }
        return result;
    }
}
```

# âœ… Approach: Stack Simulation (Optimal â€” O(L))
```java
import java.util.*;

public class Q3 {
    public int[] exclusiveTime(int n, List<String> logs) {
        int[] res = new int[n];
        Stack<Integer> stack = new Stack<>();  // âœ… Store IDs only (not full strings)
        int prevTime = 0;

        for (String s : logs) {
            int first = s.indexOf(':');
            int second = s.indexOf(':', first + 1);
            
            int id = Integer.parseInt(s.substring(0, first));
            String type = s.substring(first + 1, second);
            int time = Integer.parseInt(s.substring(second + 1));

            if (!stack.isEmpty()) {
                int runningId = stack.peek();
                if (type.equals("start")) {
                    // â¸ï¸ Pause current function: runs from prevTime to time-1
                    res[runningId] += time - prevTime;
                    stack.push(id);
                    prevTime = time;
                } else { // "end"
                    // â¹ï¸ Current function runs from prevTime to time (inclusive)
                    res[id] += time - prevTime + 1;
                    stack.pop();
                    prevTime = time + 1;  // next start at beginning of next timestamp
                }
            } else {
                stack.push(id);
                prevTime = time;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        Q3 obj = new Q3();
        String[] s = {"0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"};
        List<String> logs = Arrays.asList(s);
        System.out.println(Arrays.toString(obj.exclusiveTime(1, logs))); // [8]
    }
}
```

---

## ğŸ” Step-by-Step: Example 1  
`logs = ["0:start:0", "1:start:2", "1:end:5", "0:end:6"]`

| Log | `id` | `type` | `time` | `stack` before | `prevTime` | Action | `result` update |
|-----|------|--------|--------|----------------|------------|--------|------------------|
| `0:start:0` | 0 | start | 0 | `[]` | 0 | push 0, `prevTime=0` | â€” |
| `1:start:2` | 1 | start | 2 | `[0]` | 0 | `result[0] += 2âˆ’0 = 2` â†’ `result[0]=2`<br>push 1, `prevTime=2` | `[2,0]` |
| `1:end:5` | 1 | end | 5 | `[0,1]` | 2 | `result[1] += 5âˆ’2+1 = 4` â†’ `result[1]=4`<br>pop 1, `prevTime=6` | `[2,4]` |
| `0:end:6` | 0 | end | 6 | `[0]` | 6 | `result[0] += 6âˆ’6+1 = 1` â†’ `result[0]=3`<br>pop 0, `prevTime=7` | `[3,4]` âœ… |

### ğŸ“Œ Critical Detail: `prevTime = time + 1` after `end`  
Because:
- `"1:end:5"` â†’ function 1 runs *through end of 5*,
- So next event (`0:end:6`) starts at *beginning of 6* â†’ no overlap.

If we didnâ€™t set `prevTime = 6`, then `0:end:6` would compute `6âˆ’5 = 1` (correct), but for back-to-back events, it ensures no double-counting.

---

## âœ… Recursive Example 2  
`logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]`  
Expected: `[8]`

| Log | Action | `result[0]` |
|-----|--------|-------------|
| `0:start:0` | prevTime=0 | 0 |
| `0:start:2` | `+= 2âˆ’0 = 2` â†’ 2 | 2 |
| `0:end:5`   | `+= 5âˆ’2+1 = 4` â†’ 6 | 6 |
| `0:start:6` | `+= 6âˆ’6 = 0` â†’ 6 | 6 |
| `0:end:6`   | `+= 6âˆ’6+1 = 1` â†’ 7 | 7 |
| `0:end:7`   | `+= 7âˆ’7+1 = 1` â†’ 8 | 8 âœ… |

Perfect.

---

## ğŸ“Š Analysis

| Metric | Value |
|-------|-------|
| **Time** | O(L) â€” one pass over logs |
| **Space** | O(D) â€” stack depth (max recursion depth) |
| **Correctness** | âœ… Handles recursion, preemption, timestamp semantics |
| **Readability** | â­â­â­â­ |
| **LeetCode Runtime** | âœ… ~1â€“2 ms |

âœ… **Pros**:  
- Direct simulation â€” mirrors CPU behavior.
- Minimal state: only `stack`, `prevTime`, `result`.
- No string parsing overhead beyond `split`.


## ğŸš« Common Pitfalls (and How to Avoid)

| Mistake | Consequence | Fix |
|--------|-------------|-----|
| Forgetting `+1` in `end` case | Undercount by 1 per call | `time - prevTime + 1` âœ… |
| Using `prevTime = time` after `end` | Overlap with next start | `prevTime = time + 1` âœ… |
| Not handling empty stack (first log) | NPE or wrong time | Guard with `if (!stack.isEmpty())` or initialize properly |
| Assuming IDs are in order | Fails for non-sequential IDs | Use `id` from log, not index |


## âœ… Final Recommendation

This is a **must-know stack simulation pattern** â€” used in:
- Profilers,
- Debuggers,
- Runtime tracing.

In interviews:
1. Draw the timeline (like above),
2. Explain timestamp semantics,
3. Code the stack simulation.