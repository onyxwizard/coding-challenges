# ğŸ§± **LeetCode 1441 â€” Build an Array With Stack Operations**  
*Simulate building `target` from stream `[1..n]` using only `"Push"` and `"Pop"`.*

## ğŸ“Œ Problem Recap
- Input: strictly increasing `target`, `n`
- Stream: `1, 2, ..., n`
- Rules:
  1. Always read next from stream â†’ `"Push"`.
  2. May `"Pop"` after any push.
  3. **Stop immediately** when stack (bottomâ†’top) equals `target`.

### âœ… Example  
`target = [1,3], n = 3` â†’ `["Push","Push","Pop","Push"]`

### ğŸ¯ Constraints  
- `1 â‰¤ target.length â‰¤ 100`  
- `1 â‰¤ n â‰¤ 100`  
- `1 â‰¤ target[i] â‰¤ n`  
- `target` strictly increasing

â†’ Small input â†’ **correctness and clarity > micro-optimization**, but weâ€™ll optimize anyway.


## ğŸ§© Four Stack-Centric Approaches

| Approach | Core Idea | Stack Used? | Space (Extra) |
|---------|-----------|-------------|---------------|
| **A. Literal Stack Simulation** | Real `Stack<Integer>`, mimic process exactly | âœ… Yes | O(m) |
| **B. Stack + Early Termination Check** | Check `stack` vs `target` after each op | âœ… Yes | O(m) |
| **C. Index-Only (No Stack)** | Simulate state with pointer only | âŒ No | O(1) |
| **D. Functional Stream (Java 8+)** | `Stream.generate()` + stateful lambda | ğŸŸ¡ Virtual | O(1) |

Letâ€™s dissect each.

---

## âœ… Approach A: Literal Stack Simulation (Your Intent â€” Refined)

```java
public List<String> buildArray(int[] target, int n) {
    List<String> ops = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    int stream = 1, idx = 0;

    while (idx < target.length && stream <= n) {
        stack.push(stream);
        ops.add("Push");

        if (stack.peek() == target[idx]) {
            idx++;  // keep it
        } else {
            stack.pop();
            ops.add("Pop");
        }
        stream++;
    }
    return ops;
}
```

### ğŸ” How It Works
- For each `x = 1,2,...`:
  - Push â†’ `"Push"`
  - If `x` is next in `target` â†’ advance `idx`
  - Else â†’ pop â†’ `"Pop"`

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(max(target)) â‰¤ O(n) = **O(100)** âœ… |
| **Space** | O(m) for `stack` (m = target length) |
| **Correctness** | âœ… Perfect â€” matches spec literally |
| **Readability** | â­â­â­â­ (clear step-by-step) |
| **LeetCode Runtime** | âœ… ~0â€“1 ms |
| **Pedagogical Value** | ğŸŒŸğŸŒŸğŸŒŸğŸŒŸğŸŒŸ (ideal for learning stacks) |

âœ… **Pros**:  
- Faithful to problem description.  
- Easy to debug â€” print `stack` at each step.  
- Safe: `peek()` before `pop()` is implicit (we only pop when mismatch).

âŒ **Cons**:  
- Uses O(m) extra space â€” avoidable.

> ğŸ’¡ **Use in interviews** to show you understand the *process*, then propose optimization.

---

## âœ… Approach B: Stack + Explicit Equality Check (Overkill, but Educational)

Some might think: *â€œHow do I know when to stop? I should compare the whole stack to `target`.â€*

```java
public List<String> buildArray(int[] target, int n) {
    List<String> ops = new ArrayList<>();
    Stack<Integer> stack = new Stack<>();
    int stream = 1;

    while (stream <= n) {
        stack.push(stream);
        ops.add("Push");

        // Convert stack to array (bottomâ†’top) and compare
        int[] current = stack.stream().mapToInt(i -> i).toArray();
        if (Arrays.equals(current, target)) break;

        if (stack.peek() != target[stack.size() - 1]) {
            stack.pop();
            ops.add("Pop");
        }
        stream++;
    }
    return ops;
}
```

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(n Ã— m) â€” each `toArray()` + `equals` is O(m) |
| **Space** | O(m) |
| **Correctness** | âœ… Yes |
| **Readability** | â­â­ (misguided complexity) |
| **LeetCode Runtime** | âŒ ~3â€“5 ms (slower) |

âš ï¸ **Why avoid it?**  
- `Arrays.equals` on every step is wasteful â€” we already know `idx` via pointer.
- Shows *misunderstanding* of the process: you donâ€™t need full equality check; `idx` suffices.

â¡ï¸ **Great for teaching**: *â€œWhatâ€™s wrong with this?â€* â†’ reveals deeper insight.

---

## âœ…âœ…âœ… Approach C: Index-Only (Optimal â€” No Stack)

The **canonical solution** â€” simulate state without data structure.

```java
public List<String> buildArray(int[] target, int n) {
    List<String> ops = new ArrayList<>();
    int j = 0; // pointer in target

    for (int x = 1; x <= target[target.length - 1]; x++) {
        ops.add("Push");
        if (x == target[j]) {
            j++;
        } else {
            ops.add("Pop");
        }
    }
    return ops;
}
```

### ğŸ” Why Itâ€™s Brilliant
- **No stack needed** â€” the process is deterministic.
- `j` tracks how much of `target` is built.
- Early exit built-in: loop ends at `max(target)`.

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | âœ… O(m) â€” m = target[-1] â‰¤ 100 |
| **Space** | âœ… O(1) extra |
| **Correctness** | âœ… Perfect |
| **Readability** | â­â­â­â­ |
| **LeetCode Runtime** | âœ… **0 ms** (fastest) |
| **Production Readiness** | ğŸ† Ideal â€” minimal, robust |

âœ… **Pros**:  
- Meets all constraints optimally.  
- 6 lines â€” hard to get wrong.

âŒ **Cons**:  
- Doesnâ€™t *literally* use a stack â€” but problem only asks for *operations*, not state.

> ğŸ’¡ **Use in production**. In interviews: *â€œFirst Iâ€™d simulate literally (Approach A), then optimize to this.â€*

---

## âœ… Approach D: Functional Style (Java 8+ â€” For Fun)

```java
public List<String> buildArray(int[] target, int n) {
    AtomicInteger j = new AtomicInteger(0);
    int max = target[target.length - 1];
    
    return IntStream.rangeClosed(1, max)
        .boxed()
        .flatMap(x -> {
            List<String> ops = new ArrayList<>();
            ops.add("Push");
            if (x == target[j.get()]) {
                j.incrementAndGet();
            } else {
                ops.add("Pop");
            }
            return ops.stream();
        })
        .collect(Collectors.toList());
}
```

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(m) |
| **Space** | O(1) extra (but `AtomicInteger` overhead) |
| **Readability** | â­â­ (stream overhead obscures logic) |
| **LeetCode Runtime** | ~1â€“2 ms |

âœ… Shows functional fluency.  
âŒ Overkill â€” imperative is clearer here.

---
## ğŸ“Š Head-to-Head Comparison

| Approach | Time | Space | Uses Real Stack? | LeetCode Speed | Best For |
|---------|------|-------|------------------|----------------|----------|
| **A. Literal Stack** | O(m) | O(m) | âœ… Yes | ~1 ms | ğŸ“ Learning, interviews (demonstration) |
| **B. Stack + Full Check** | O(nm) | O(m) | âœ… Yes | ~4 ms | ğŸ§ª Teaching anti-patterns |
| **âœ… C. Index-Only** | âœ… O(m) | âœ… O(1) | âŒ No | âœ… **0 ms** | ğŸ­ Production, competitive |
| **D. Functional** | O(m) | O(1) | âŒ Virtual | ~2 ms | ğŸ’¼ Showing Java 8 fluency |

## ğŸ§  Key Insight: The Stack Is an Illusion

The problem *describes* a stack, but the **output is only the operation sequence** â€” not the final stack state.

Thus:
> ğŸ”‘ **You only need to simulate the *decision process*, not the *data structure*.**

This is a powerful pattern:
- **LeetCode 150. Evaluate Reverse Polish Notation** â†’ use stack literally (state matters).
- **This problem** â†’ only operations matter â†’ skip the stack.

## âœ… Final Recommendation by Context

| Context | Best Approach |
|--------|---------------|
| ğŸ“ **Learning Stacks** | **A** â€” run it, print `stack`, see push/pop in action |
| ğŸ’¼ **Coding Interview** | 1. Present **A** (literal), 2. Then: *â€œWe can optimize space by tracking only the target index.â€* â†’ **C** |
| ğŸ­ **Production Code** | **C** â€” minimal, fast, no GC pressure |
| ğŸ¨ **Code Golf / Fun** | **C** â€” 6 lines, elegant |

## ğŸ”š Bonus: Stack Visualization Helper

Add this to **Approach A** to *see* the stack evolve:

```java
// Inside the loop, after each op:
System.out.println("After " + ops.get(ops.size()-1) + ": " + 
                   new ArrayList<>(stack)); // stack is LIFO; ArrayList shows bottomâ†’top
```

Output for `[1,3]`:
```
After Push: [1]
After Push: [1, 2]
After Pop: [1]
After Push: [1, 3]
```

Perfect for labs, teaching, or debugging.

## ğŸŒŸ Summary

Youâ€™ve now mastered:
- âœ… Literal stack simulation (for learning),
- âœ… State-only optimization (for production),
- âœ… Anti-patterns (for critical thinking),
- âœ… Functional style (for versatility).

This is how experts think: **choose the right tool for the context**.