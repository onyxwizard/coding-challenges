**Goal**: Given `heights = [h‚ÇÄ, h‚ÇÅ, ..., h‚Çô‚Çã‚ÇÅ]`, find the largest rectangle in the histogram.

A rectangle is defined by:
- A **contiguous segment** of bars: indices `[L, R]`
- Its **height** = `min(heights[L..R])`
- Its **area** = `width √ó height` = `(R - L + 1) √ó min(...)`

Brute force: O(n¬≤) ‚Äî try all L, R.  
We want **O(n)**.

---

## üåü Core Insight (The ‚ÄúAha!‚Äù)
> ‚úÖ **Every maximal rectangle is ‚Äúsupported‚Äù by at least one bar that is *the shortest* in that rectangle.**  
> So for each bar `i`, ask:  
> _‚ÄúHow far can I extend to the left and right *while staying ‚â• `heights[i]`*?‚Äù_

If:
- `left[i]` = index of first bar **to the left** *strictly shorter* than `heights[i]`  
- `right[i]` = index of first bar **to the right** *strictly shorter* than `heights[i]`

Then the widest rectangle **with height = `heights[i]`** has:
- Width = `right[i] - left[i] - 1`
- Area = `heights[i] * (right[i] - left[i] - 1)`

So problem reduces to: compute `left[i]` and `right[i]` for all `i` ‚Üí take max area.

And ‚Äî here‚Äôs the magic ‚Äî **we can compute both in one pass** using a *monotonic stack*.

---

## üß± Step-by-Step Code Construction

Let‚Äôs build the code incrementally.

### ‚úÖ Step 1: Setup ‚Äî What do we need?
```java
import java.util.Stack;

public class Q3 {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();  // stores INDICES, not values
        int maxArea = 0;
        int n = heights.length;
```
- **Why indices?** So we can compute distances: `i - j`.
- **Why `Stack<Integer>`?** We need LIFO access to quickly ‚Äúundo‚Äù recent tall bars when a short one arrives.

---

### ‚úÖ Step 2: The Loop ‚Äî Extend to `i = n` (sentinel trick)
```java
        for (int i = 0; i <= n; i++) {
```
- We loop to `i = n` (one past the last index).
- **Why?** To ensure *all* bars get popped and processed ‚Äî even those in an increasing tail like `[1,2,3]`.
- Think of `heights[n]` as a **sentinel bar of height 0** ‚Äî it‚Äôs shorter than everything, so it forces all remaining bars out of the stack.

---

### ‚úÖ Step 3: Current Height ‚Äî Handle Sentinel Gracefully
```java
            int curHeight = (i == n) ? 0 : heights[i];
```
- When `i < n`: use real bar height.
- When `i == n`: use `0` to flush the stack.
- üí° This avoids writing a second while-loop after the for-loop. Elegant and safe.

---

### ‚úÖ Step 4: The While Loop ‚Äî ‚ÄúFinalize rectangles of taller bars‚Äù
```java
            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
```
- **Condition meaning**:  
  ‚ÄúThe current bar (`i`) is *shorter* than the bar at the top of the stack.‚Äù  
  ‚Üí So the top bar *cannot extend further right* ‚Äî its right boundary is `i`.

- ‚úÖ **Key invariant**:  
  The stack is always **strictly increasing in height** (i.e., `heights[stack[0]] < heights[stack[1]] < ...`).  
  We maintain this by popping any bar taller than the current one.

---

### ‚úÖ Step 5: Pop and Compute ‚Äî The Heart of the Algorithm
Now, inside the while loop:

#### üîπ 5.1 Pop the index we‚Äôre finalizing
```java
                int idx = stack.pop();        // the bar whose rectangle we're computing
```
- `idx` is the index of a bar that is **taller than `curHeight`**, so `i` is its *first smaller to the right*.

#### üîπ 5.2 Its height is fixed
```java
                int height = heights[idx];
```

#### üîπ 5.3 Find its *left boundary*
```java
                int leftBoundary = stack.isEmpty() ? -1 : stack.peek();
```
- After popping `idx`, the new top of the stack is the **nearest index to the left with height < `height`**.
- Why? Because we only kept smaller bars in the stack (monotonic increasing).
- If stack is empty ‚Üí no bar to the left is smaller ‚Üí left boundary is `-1`.

#### üîπ 5.4 Compute width
```java
                int width = i - leftBoundary - 1;
```
Let‚Äôs verify with a diagram:

```
indices:   ...  L         idx           i  ...
heights:   ... <h     [ >=h ... >=h ]   <h
                      ‚Üê‚îÄ‚îÄ width ‚îÄ‚îÄ‚Üí
```
- The rectangle of height `h = heights[idx]` spans from `L+1` to `i-1`.
- So number of bars = `(i - 1) - (L + 1) + 1 = i - L - 1`.

‚úÖ Exactly: `width = i - leftBoundary - 1`.

#### üîπ 5.5 Update maxArea
```java
                maxArea = Math.max(maxArea, height * width);
```

---

### ‚úÖ Step 6: Push Current Index
```java
            stack.push(i);
```
- After popping all taller bars, the stack is again increasing.
- Push `i` ‚Äî it‚Äôs now the tallest (or equal) in the stack, ready to extend rightward.

> ‚ö†Ô∏è Note: We push even `i = n` (sentinel), but since `curHeight = 0`, and nothing is < 0, it stays alone ‚Äî harmless.

---

### ‚úÖ Step 7: Return Result
```java
        return maxArea;
    }
}
```

---

## üß™ Full Trace: `heights = [2, 1, 5, 6, 2, 3]`

| `i` | `curHeight` | `stack` (before while) | Action | Pop? `idx` | `height` | `leftBoundary` | `width` | `area` | `maxArea` |
|-----|-------------|------------------------|--------|------------|----------|----------------|---------|--------|-----------|
| 0   | 2           | `[]`                   | push   | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 0         |
| 1   | 1           | `[0]`                  | while  | `0`        | 2        | -1             | 1-(-1)-1=1 | 2   | 2         |
|     |             | `[]`                   | push 1 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 2         |
| 2   | 5           | `[1]`                  | push 2 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 2         |
| 3   | 6           | `[1,2]`                | push 3 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 2         |
| 4   | 2           | `[1,2,3]`              | while  | `3`        | 6        | 2              | 4-2-1=1 | 6      | 6         |
|     |             | `[1,2]`                | while  | `2`        | 5        | 1              | 4-1-1=2 | 10     | 10 ‚úÖ     |
|     |             | `[1]`                  | push 4 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 10        |
| 5   | 3           | `[1,4]`                | push 5 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 10        |
| 6   | 0 (sentinel)| `[1,4,5]`              | while  | `5`        | 3        | 4              | 6-4-1=1 | 3      | 10        |
|     |             | `[1,4]`                | while  | `4`        | 2        | 1              | 6-1-1=4 | 8      | 10        |
|     |             | `[1]`                  | while  | `1`        | 1        | -1             | 6-(-1)-1=6 | **6** | 10        |
|     |             | `[]`                   | push 6 | ‚Äî          | ‚Äî        | ‚Äî              | ‚Äî       | ‚Äî      | 10        |

‚úÖ Final answer: **10** (from bar `5` and `6` ‚Üí width=2, height=5)

---

## üß† Pattern Summary: Monotonic Stack Template

You can now generalize this to any ‚Äúnearest smaller‚Äù problem:

```java
Stack<Integer> stack = new Stack<>();
for (int i = 0; i <= n; i++) {
    int cur = (i == n) ? SENTINEL : arr[i];
    while (!stack.isEmpty() && cur REL_OP arr[stack.peek()]) {  // < for min, > for max
        int j = stack.pop();
        int h = arr[j];
        int left = stack.isEmpty() ? BOUND : stack.peek();
        int w = i - left - 1;
        // ... compute result ...
    }
    stack.push(i);
}
```

| Problem | `REL_OP` | `SENTINEL` | `BOUND` |
|--------|----------|------------|---------|
| Largest rectangle (min-limited) | `<` | `0` | `-1` |
| Trapping rain water (needs nearest *greater*) | `>` | `‚àû` (e.g., `Integer.MAX_VALUE`) | `-1` |
| Sum of subarray minimums | `<` | `0` | `-1` |

---

## ‚úÖ Final Working Code (Annotated)

```java
import java.util.Stack;

public class Q3 {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();  // stores indices of bars (increasing height)
        int maxArea = 0;
        int n = heights.length;

        // Loop to n (inclusive) to use sentinel and flush stack
        for (int i = 0; i <= n; i++) {
            // Current height: 0 at i == n acts as sentinel (shorter than all)
            int curHeight = (i == n) ? 0 : heights[i];

            // While current bar is shorter than top of stack:
            // ‚Üí top bar cannot extend further right; finalize its rectangle
            while (!stack.isEmpty() && curHeight < heights[stack.peek()]) {
                int idx = stack.pop();                   // bar being finalized
                int height = heights[idx];               // its height
                int leftBoundary = stack.isEmpty() ? -1 : stack.peek(); // first smaller to left
                int width = i - leftBoundary - 1;        // span where height is minimum
                maxArea = Math.max(maxArea, height * width);
            }

            // Push current index ‚Äî stack remains increasing
            stack.push(i);
        }

        return maxArea;
    }
}
```

---