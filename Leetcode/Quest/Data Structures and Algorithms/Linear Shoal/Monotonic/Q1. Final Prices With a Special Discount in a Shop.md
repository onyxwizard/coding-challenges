# Q1. Final Prices With a Special Discount in a Shop
## ğŸ“Œ Problem Summary

Given `prices[i]`, for each item:
- Find the **first** `j > i` such that `prices[j] â‰¤ prices[i]`,
- Then final price = `prices[i] - prices[j]`,
- If no such `j`, pay full `prices[i]`.

### âœ… Examples
| `prices` | `answer` | Explanation |
|----------|----------|-------------|
| `[8,4,6,2,3]` | `[4,2,4,2,3]` | 8âˆ’4, 4âˆ’2, 6âˆ’2, 2, 3 |
| `[1,2,3,4,5]` | `[1,2,3,4,5]` | strictly increasing â†’ no discounts |
| `[10,1,1,6]` | `[9,0,1,6]` | 10âˆ’1, 1âˆ’1, 1, 6 |

### ğŸ¯ Constraints
- `1 â‰¤ prices.length â‰¤ 500`  
- `1 â‰¤ prices[i] â‰¤ 1000`

â†’ Small `n` â†’ **O(nÂ²) brute force passes**, but the *intended solution* is **O(n) with monotonic stack**.


## ğŸ” Key Insight: This Is "Next Smaller or Equal Element"

This is the **exact** same pattern as:
- **LeetCode 739. Daily Temperatures** (next *greater*),
- **LeetCode 496. Next Greater Element I**,
- **LeetCode 503. Next Greater Element II**.

Here: **next smaller or equal element to the right**.

> ğŸ”‘ **Monotonic increasing stack** (store indices) gives us O(n) time.

---

## âœ… Approach A: Brute Force (O(nÂ²)) â€” Works for n=500

```java
public int[] finalPrices(int[] prices) {
    int n = prices.length;
    int[] res = new int[n];
    
    for (int i = 0; i < n; i++) {
        int discount = 0;
        for (int j = i + 1; j < n; j++) {
            if (prices[j] <= prices[i]) {
                discount = prices[j];
                break;
            }
        }
        res[i] = prices[i] - discount;
    }
    return res;
}
```

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | O(nÂ²) = 500Â² = 250,000 ops âœ… |
| **Space** | O(1) |
| **LeetCode Runtime** | âœ… ~1 ms |
| **Readability** | â­â­â­â­â­ |

âœ… **Pros**:  
- Dead simple â€” zero cognitive load.  
- Perfect for interviews as a baseline.

âŒ **Cons**:  
- Doesnâ€™t scale: `n = 10âµ` â†’ 10Â¹â° ops (impossible).  
- Misses the *pattern* â€” limits growth.

> ğŸ’¡ Use first in interviews, then optimize.

---

## âœ…âœ…âœ… Approach B: Monotonic Stack (O(n)) â€” The Elegant Solution

### ğŸ§  Idea
Traverse **right to left**, maintain a stack of candidate discounts (indices).  
For each `i`:
- Pop from stack while `prices[stack.peek()] > prices[i]` (we want â‰¤),
- Then:
  - If stack not empty â†’ `discount = prices[stack.peek()]`,
  - Else â†’ no discount,
- Push `i` onto stack.

But note: we want **first `j > i` with `prices[j] â‰¤ prices[i]`** â†’ so stack should store indices in **increasing price order**.

Actually, simpler: traverse **left to right** with a stack of *unprocessed indices*.

### âœ… Standard Method: Process on "Resolution"

```java
public int[] finalPrices(int[] prices) {
    int n = prices.length;
    int[] res = prices.clone();  // start with full price
    Stack<Integer> stack = new Stack<>(); // stores indices

    for (int i = 0; i < n; i++) {
        // While current price <= price at top of stack â†’ resolve discount
        while (!stack.isEmpty() && prices[i] <= prices[stack.peek()]) {
            int idx = stack.pop();
            res[idx] = prices[idx] - prices[i];  // apply discount
        }
        stack.push(i);
    }
    // Remaining in stack get no discount (already set to prices[i])
    return res;
}
```

### ğŸ” Step-by-Step: `prices = [8,4,6,2,3]`

| `i` | `prices[i]` | Stack (indices) | Action |
|-----|-------------|-----------------|--------|
| 0 | 8 | `[]` â†’ push 0 | `[0]` |
| 1 | 4 | `8 â‰¥ 4` â†’ pop 0: `res[0] = 8âˆ’4 = 4`, push 1 | `[1]` |
| 2 | 6 | `4 â‰¤ 6` â†’ push 2 | `[1,2]` |
| 3 | 2 | `6 â‰¥ 2` â†’ pop 2: `res[2] = 6âˆ’2 = 4`<br>`4 â‰¥ 2` â†’ pop 1: `res[1] = 4âˆ’2 = 2`, push 3 | `[3]` |
| 4 | 3 | `2 â‰¤ 3` â†’ push 4 | `[3,4]` |

Final `res = [4,2,4,2,3]` âœ…  
Indices `3,4` remain â†’ no discount â†’ `res[3]=2`, `res[4]=3` (already set by clone).

### ğŸ“Š Analysis
| Metric | Value |
|-------|-------|
| **Time** | âœ… O(n) â€” each index pushed/popped once |
| **Space** | O(n) stack (worst-case decreasing array) |
| **LeetCode Runtime** | âœ… **0 ms** |
| **Readability** | â­â­â­â­ (once you know the pattern) |

âœ… **Pros**:  
- Linear time â€” scales to `n = 10â¶`.  
- Teaches **monotonic stack** â€” a top interview pattern.

---

## âœ… Approach C: Right-to-Left Stack (Alternative)

```java
public int[] finalPrices(int[] prices) {
    int n = prices.length;
    int[] res = new int[n];
    Stack<Integer> stack = new Stack<>(); // stores prices (or indices)

    for (int i = n - 1; i >= 0; i--) {
        // Pop until top â‰¤ prices[i]
        while (!stack.isEmpty() && stack.peek() > prices[i]) {
            stack.pop();
        }
        res[i] = prices[i] - (stack.isEmpty() ? 0 : stack.peek());
        stack.push(prices[i]);
    }
    return res;
}
```

âœ… Also O(n), but uses **price values** (not indices).  
âš ï¸ Slightly less flexible if you need index info.

---

## ğŸ“Š Comparison Summary

| Approach | Time | Space | Scalability | LeetCode Speed | When to Use |
|---------|------|-------|-------------|----------------|-------------|
| **A. Brute Force** | O(nÂ²) | O(1) | âŒ Poor | ~1 ms | Interviews (baseline), small `n` |
| **âœ… B. Monotonic Stack (leftâ†’right)** | âœ… O(n) | O(n) | âœ… Excellent | âœ… **0 ms** | **Best** â€” optimal, teachable |
| **C. Right-to-Left Stack** | O(n) | O(n) | âœ… Excellent | âœ… 0 ms | If you prefer backward traversal |

## ğŸš« Common Pitfalls

| Mistake | Consequence | Fix |
|--------|-------------|-----|
| Using `<` instead of `<=` | Misses equal-price discounts (e.g., `[5,5]` â†’ should be `[0,5]`) | Use `<=` in condition âœ… |
| Forgetting to clone `prices` | Mutates input (problem allows, but unsafe) | `res = prices.clone()` or compute on fly |
| Processing stack after loop | Unnecessary â€” remaining get no discount (already full price) | No extra loop needed |


## âœ… Final Recommendation

| Context | Best Choice |
|--------|-------------|
| ğŸ“ Learning | **A â†’ B** (show progression) |
| ğŸ’¼ Interview | Start with **A**, then: *â€œWe can optimize to O(n) using a monotonic stack â€” hereâ€™s how.â€* â†’ **B** |
| ğŸ­ Production | **B** â€” fastest, most scalable |
| ğŸ† Competitive | **B** â€” 10 lines, 0 ms |


## ğŸ”š Bonus: Why Monotonic Stack?

The stack maintains **potential future discounts** in increasing order:
- Bottom â†’ top: prices are **non-decreasing**,
- When a smaller price arrives, it *resolves* all larger pending items.

This is the same logic used in:
- Histogram largest rectangle,
- Trapping rain water,
- Stock span problem.

Master this, and a whole class of problems becomes trivial.